#!/usr/bin/env node

/**
 * PAWS cats CLI - Create Context Bundle
 * Prepares a cats.md bundle with curated context for AI agents
 */

const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');

// Load configuration
let userConfig = {};
try {
  const { getConfig } = require('../utils/config-loader.js');
  const configLoader = getConfig();
  configLoader.load();
  userConfig = configLoader.get('cli', {});
} catch (err) {
  // Config loader not available, use defaults
}

// Parse command line arguments
const args = process.argv.slice(2);

// Configuration
const config = {
  output: 'cats.md',
  pattern: [],
  exclude: userConfig.excludeDirs || ['node_modules', '.git', 'dist', 'build', '.cache'],
  maxSize: userConfig.maxFileSize || 100000, // Max file size to include
  verbose: userConfig.verbose || false,
  help: false,
  validate: false
};

// Parse arguments
for (let i = 0; i < args.length; i++) {
  switch (args[i]) {
    case 'validate':
      config.validate = true;
      if (args[i + 1] && !args[i + 1].startsWith('-')) {
        config.output = args[++i];
      }
      break;
    case '-o':
    case '--output':
      config.output = args[++i];
      break;
    case '-p':
    case '--pattern':
      config.pattern.push(args[++i]);
      break;
    case '-e':
    case '--exclude':
      config.exclude.push(args[++i]);
      break;
    case '-v':
    case '--verbose':
      config.verbose = true;
      break;
    case '-h':
    case '--help':
      config.help = true;
      break;
    default:
      if (!args[i].startsWith('-')) {
        config.pattern.push(args[i]);
      }
  }
}

// Show help
if (config.help || (args.length === 0 && !config.validate)) {
  console.log(`
PAWS cats CLI - Create Context Bundle

Usage: cats [options] [patterns...]
       cats validate <bundle>

Commands:
  validate <bundle>      Validate cats bundle format

Options:
  -o, --output <file>    Output file (default: cats.md)
  -p, --pattern <glob>   Include files matching pattern
  -e, --exclude <dir>    Exclude directory (default: node_modules, .git)
  -v, --verbose         Verbose output
  -h, --help           Show help

Examples:
  cats "*.js"                     # Include all JS files
  cats -p "src/**/*.ts" -o context.cats.md  # TypeScript in src/
  cats "*.json" "*.yml" -e tests  # JSON/YAML excluding tests/
  cats validate context.cats.md   # Validate bundle format
`);
  process.exit(0);
}

// Logging helper
const log = (msg) => {
  if (config.verbose) {
    console.error(`[cats] ${msg}`);
  }
};

// Check if file should be excluded
const shouldExclude = (filePath) => {
  const parts = filePath.split(path.sep);
  return config.exclude.some(ex => parts.includes(ex));
};

// Get file size
const getFileSize = async (filePath) => {
  try {
    const stats = await fs.stat(filePath);
    return stats.size;
  } catch {
    return 0;
  }
};

// Find files matching patterns
const findFiles = async () => {
  const files = new Set();

  // If no patterns specified, use common source patterns
  const patterns = config.pattern.length > 0 ? config.pattern : [
    '*.js', '*.ts', '*.jsx', '*.tsx', '*.json', '*.yml', '*.yaml',
    '*.md', '*.py', '*.go', '*.rs', '*.java', '*.rb'
  ];

  for (const pattern of patterns) {
    try {
      // Security: Use fast-glob library instead of shell commands to prevent injection
      // For now, validate pattern to prevent shell injection
      if (pattern.includes(';') || pattern.includes('&') || pattern.includes('|') || pattern.includes('`') || pattern.includes('$')) {
        log(`Skipping potentially unsafe pattern: ${pattern}`);
        continue;
      }

      // Use find command for glob patterns
      const cmd = process.platform === 'win32'
        ? `dir /b /s ${pattern.replace(/\//g, '\\')}`
        : `find . -name "${pattern}" -type f 2>/dev/null`;

      const output = execSync(cmd, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'ignore'] });
      const foundFiles = output.split('\n').filter(Boolean);

      for (const file of foundFiles) {
        const normalizedPath = path.relative(process.cwd(), file.trim());
        if (!shouldExclude(normalizedPath)) {
          const size = await getFileSize(normalizedPath);
          if (size > 0 && size <= config.maxSize) {
            files.add(normalizedPath);
          }
        }
      }
    } catch (err) {
      log(`Pattern ${pattern} returned no files`);
    }
  }

  return Array.from(files).sort();
};

// Create cats bundle
const createCatsBundle = async (files) => {
  const sections = [];

  // Add metadata
  sections.push(`# Context Bundle (cats.md)
Generated: ${new Date().toISOString()}
Files: ${files.length}
Purpose: Curated context for AI-assisted development

---
`);

  // Add file contents
  for (const file of files) {
    try {
      const content = await fs.readFile(file, 'utf8');
      const ext = path.extname(file).slice(1) || 'txt';

      sections.push(`## File: ${file}

\`\`\`${ext}
${content}
\`\`\`

---
`);

      log(`Added ${file}`);
    } catch (err) {
      log(`Failed to read ${file}: ${err.message}`);
    }
  }

  return sections.join('\n');
};

// Validate cats bundle
const validateCatsBundle = (content) => {
  const errors = [];

  // Check for required header
  if (!content.includes('# Context Bundle')) {
    errors.push('Missing "# Context Bundle" header');
  }

  // Check for metadata section
  if (!content.includes('Generated:')) {
    errors.push('Missing "Generated:" metadata field');
  }

  // Check file blocks format
  const fileRegex = /## File: (.+)\n\n```[\w]*\n([\s\S]*?)```/g;
  let fileCount = 0;
  let match;

  while ((match = fileRegex.exec(content)) !== null) {
    fileCount++;
    const [, filePath, fileContent] = match;

    // Validate file path
    if (!filePath || filePath.trim().length === 0) {
      errors.push(`File ${fileCount}: Empty file path`);
    } else if (filePath.includes('..')) {
      errors.push(`File ${fileCount}: Path contains ".." (potential security issue): ${filePath}`);
    }

    // Check for empty content
    if (!fileContent || fileContent.trim().length === 0) {
      errors.push(`File ${fileCount}: Empty file content for ${filePath}`);
    }
  }

  if (fileCount === 0) {
    errors.push('No file blocks found. Expected format: ## File: path\\n```\\ncontent\\n```');
  }

  return { errors, fileCount };
};

// Extract file list from bundle
const extractFileList = (content) => {
  const files = [];
  const fileRegex = /## File: (.+)\n/g;
  let match;

  while ((match = fileRegex.exec(content)) !== null) {
    files.push(match[1].trim());
  }

  return files;
};

// Main execution
const main = async () => {
  try {
    // Handle validate command
    if (config.validate) {
      log(`Validating bundle: ${config.output}`);

      try {
        const content = await fs.readFile(config.output, 'utf8');
        const { errors, fileCount } = validateCatsBundle(content);

        if (errors.length === 0) {
          console.log('‚úì Bundle is valid');

          // Show summary
          const files = extractFileList(content);
          console.log(`\nüì¶ Bundle contains ${fileCount} files:`);
          files.forEach(f => console.log(`  - ${f}`));

          const stats = await fs.stat(config.output);
          console.log(`\nSize: ${(stats.size / 1024).toFixed(1)}KB`);
        } else {
          console.log('‚úó Bundle has errors:\n');
          errors.forEach(err => console.log(`  ‚ùå ${err}`));
          console.log('\nTip: Use cats to create a properly formatted bundle');
          process.exit(1);
        }
      } catch (err) {
        if (err.code === 'ENOENT') {
          console.error(`‚ùå Bundle file not found: ${config.output}`);
          console.error('Tip: Check that the file path is correct');
        } else {
          console.error(`‚ùå Error reading bundle: ${err.message}`);
        }
        process.exit(1);
      }
      return;
    }

    // Normal bundle creation
    log('Finding files...');
    const files = await findFiles();

    if (files.length === 0) {
      console.error('‚ùå No files found matching patterns');
      console.error('\nSuggestions:');
      console.error('  ‚Ä¢ Check that file patterns are correct');
      console.error('  ‚Ä¢ Try using quotes around patterns with wildcards: cats "src/**/*.js"');
      console.error('  ‚Ä¢ Use --verbose to see detailed search information');
      console.error('  ‚Ä¢ Make sure you are in the correct directory');
      console.error('\nExample: cats "*.js" "src/**/*.ts" -o context.cats.md --verbose');
      process.exit(1);
    }

    console.log(`Found ${files.length} files`);

    log('Creating bundle...');
    const bundle = await createCatsBundle(files);

    log(`Writing to ${config.output}...`);
    await fs.writeFile(config.output, bundle);

    console.log(`‚úì Created ${config.output} with ${files.length} files`);

    // Display summary
    const stats = await fs.stat(config.output);
    console.log(`  Size: ${(stats.size / 1024).toFixed(1)}KB`);

  } catch (err) {
    console.error(`Error: ${err.message}`);
    process.exit(1);
  }
};

// Run if executed directly
if (require.main === module) {
  main();
}

module.exports = { createCatsBundle, findFiles };