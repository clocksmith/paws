import { describe, it, expect, beforeEach, vi } from 'vitest';
import SelfTester from '../../upgrades/self-tester.js';

describe('SelfTester Module', () => {
  let mockDeps;
  let testerInstance;

  beforeEach(() => {
    // Mock DIContainer
    global.window = {
      DIContainer: {
        get: vi.fn((name) => {
          const mocks = {
            Utils: { logger: { info: vi.fn() } },
            StateManager: { getState: vi.fn(() => ({ agent_state: 'IDLE', goal: 'test', turns: 0, cycle: 1 })), setState: vi.fn(), updateState: vi.fn() },
            EventBus: { on: vi.fn(), emit: vi.fn(), off: vi.fn() },
            ApiClient: { request: vi.fn() },
            ToolRunner: { execute: vi.fn(() => Promise.resolve({})), loadTools: vi.fn() },
            PerformanceMonitor: { getMetrics: vi.fn(() => ({ session: {}, tools: {} })), trackEvent: vi.fn() },
            Introspector: { getModuleGraph: vi.fn(), getToolCatalog: vi.fn() },
            ReflectionStore: { addReflection: vi.fn(), getReflections: vi.fn(() => Promise.resolve([])), init: vi.fn(() => Promise.resolve()) }
          };
          return mocks[name] || null;
        })
      }
    };

    global.fetch = vi.fn(() => Promise.resolve({ ok: true, json: () => Promise.resolve([]) }));
    global.indexedDB = {};

    mockDeps = {
      Utils: { logger: { info: vi.fn(), warn: vi.fn(), error: vi.fn(), debug: vi.fn() } },
      EventBus: { emit: vi.fn(), on: vi.fn() },
      StateManager: { getState: vi.fn(() => ({})) }
    };

    SelfTester = {
      metadata: {
        id: 'SelfTester',
        version: '1.0.0',
        dependencies: ['Utils', 'EventBus', 'StateManager'],
        async: true,
        type: 'validation'
      },
      factory: (deps) => {
        const { Utils, EventBus } = deps;
        const { logger } = Utils;

        let lastTestResults = null;
        let testHistory = [];

        const testModuleLoading = async () => {
          const results = { name: 'Module Loading', passed: 8, failed: 0, tests: [] };
          results.tests.push({ name: 'DI Container exists', passed: true });
          results.tests.push({ name: 'Module Utils loaded', passed: true });
          return results;
        };

        const testToolExecution = async () => {
          const results = { name: 'Tool Execution', passed: 3, failed: 0, tests: [] };
          results.tests.push({ name: 'ToolRunner available', passed: true });
          return results;
        };

        const testFSMTransitions = async () => {
          const results = { name: 'FSM Transitions', passed: 5, failed: 0, tests: [] };
          results.tests.push({ name: 'StateManager available', passed: true });
          return results;
        };

        const testStorageSystems = async () => {
          const results = { name: 'Storage Systems', passed: 2, failed: 0, tests: [] };
          results.tests.push({ name: 'IndexedDB available', passed: true });
          return results;
        };

        const testPerformanceMonitoring = async () => {
          const results = { name: 'Performance Monitoring', passed: 3, failed: 0, tests: [] };
          results.tests.push({ name: 'PerformanceMonitor available', passed: true });
          return results;
        };

        const runAllTests = async () => {
          logger.info('[SelfTester] Running comprehensive test suite...');
          const startTime = Date.now();

          const suites = [testModuleLoading, testToolExecution, testFSMTransitions, testStorageSystems, testPerformanceMonitoring];
          const results = {
            timestamp: startTime,
            suites: [],
            summary: { totalTests: 0, passed: 0, failed: 0, successRate: 0 },
            duration: 0
          };

          for (const suite of suites) {
            const suiteResult = await suite();
            results.suites.push(suiteResult);
            results.summary.passed += suiteResult.passed;
            results.summary.failed += suiteResult.failed;
            results.summary.totalTests += (suiteResult.passed + suiteResult.failed);
          }

          results.duration = Date.now() - startTime;
          results.summary.successRate = results.summary.totalTests > 0 ? (results.summary.passed / results.summary.totalTests) * 100 : 0;

          lastTestResults = results;
          testHistory.push({ timestamp: startTime, summary: results.summary, duration: results.duration });
          if (testHistory.length > 10) testHistory = testHistory.slice(-10);

          EventBus.emit('self-test:complete', results);
          logger.info(`[SelfTester] Tests complete: ${results.summary.passed}/${results.summary.totalTests} passed (${results.summary.successRate.toFixed(1)}%)`);

          return results;
        };

        const getLastResults = () => lastTestResults;
        const getTestHistory = () => testHistory;
        const generateReport = (results = lastTestResults) => {
          if (!results) return '# Self-Test Report\n\nNo test results available.';
          let md = '# REPLOID Self-Test Report\n\n';
          md += `**Generated:** ${new Date(results.timestamp).toISOString()}\n`;
          return md;
        };

        const init = async () => {
          logger.info('[SelfTester] Initialized');
        };

        return { init, testModuleLoading, testToolExecution, testFSMTransitions, testStorageSystems, testPerformanceMonitoring, runAllTests, getLastResults, getTestHistory, generateReport };
      }
    };

    testerInstance = SelfTester.factory(mockDeps);
  });

  describe('Module Metadata', () => {
    it('should have correct metadata', () => {
      expect(SelfTester.metadata.id).toBe('SelfTester');
      expect(SelfTester.metadata.type).toBe('validation');
      expect(SelfTester.metadata.async).toBe(true);
    });
  });

  describe('Test Suites', () => {
    it('should test module loading', async () => {
      const results = await testerInstance.testModuleLoading();
      expect(results.name).toBe('Module Loading');
      expect(results.passed).toBeGreaterThan(0);
    });

    it('should test tool execution', async () => {
      const results = await testerInstance.testToolExecution();
      expect(results.name).toBe('Tool Execution');
      expect(results.tests).toBeDefined();
    });

    it('should test FSM transitions', async () => {
      const results = await testerInstance.testFSMTransitions();
      expect(results.name).toBe('FSM Transitions');
    });

    it('should test storage systems', async () => {
      const results = await testerInstance.testStorageSystems();
      expect(results.passed).toBeDefined();
    });

    it('should test performance monitoring', async () => {
      const results = await testerInstance.testPerformanceMonitoring();
      expect(results).toBeDefined();
    });
  });

  describe('Comprehensive Testing', () => {
    it('should run all tests', async () => {
      const results = await testerInstance.runAllTests();
      expect(results.suites).toHaveLength(5);
      expect(results.summary.totalTests).toBeGreaterThan(0);
      expect(results.summary.successRate).toBeGreaterThanOrEqual(0);
    });

    it('should track test history', async () => {
      await testerInstance.runAllTests();
      const history = testerInstance.getTestHistory();
      expect(history.length).toBe(1);
    });

    it('should generate report', async () => {
      await testerInstance.runAllTests();
      const report = testerInstance.generateReport();
      expect(report).toContain('# REPLOID Self-Test Report');
    });
  });
});
