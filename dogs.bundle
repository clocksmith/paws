

ğŸ• --- DOGS_START_FILE: dogs.py ---
#!/usr/bin/env python3

-- coding: utf-8 --

import sys
import os
import argparse
import base64
import re
from typing import List, Tuple, Dict, Optional, Any

DEFAULT_ENCODING = "utf-8"
DEFAULT_INPUT_BUNDLE_FILENAME = "dogs_in.bundle"
DEFAULT_OUTPUT_DIR = "."

CATS_BUNDLE_HEADER_PREFIX = "# Cats Bundle"
DOGS_BUNDLE_HEADER_PREFIX = "# Dogs Bundle"
BUNDLE_FORMAT_PREFIX = "# Format: "
BASE64_HINT_TEXT_IN_MARKER = "Content:Base64"

FILE_START_MARKER_REGEX_TEMPLATE = r"^\s*{emoji}\s*-{{3,}}\s*{type}_START_FILE\s*:\s*(.+?)(?:\s+
(
â„
ğ‘–
ğ‘›
ğ‘¡
ğ‘¡
ğ‘’
ğ‘¥
ğ‘¡
ğ‘–
ğ‘›
ğ‘š
ğ‘
ğ‘Ÿ
ğ‘˜
ğ‘’
ğ‘Ÿ
)
(hint
t
	â€‹

ext
i
	â€‹

n
m
	â€‹

arker)
)?\s*-{{3,}}$"

CATS_FILE_START_MARKER_REGEX = re.compile(
FILE_START_MARKER_REGEX_TEMPLATE.format(emoji="ğŸˆ", type="CATS", hint_text_in_marker=BASE64_HINT_TEXT_IN_MARKER), re.IGNORECASE
)
CATS_FILE_END_MARKER_REGEX = re.compile(r"^\sğŸˆ\s-{3,}\sCATS_END_FILE\s-{3,}$", re.IGNORECASE)

DOGS_FILE_START_MARKER_REGEX = re.compile(
FILE_START_MARKER_REGEX_TEMPLATE.format(emoji="ğŸ•", type="DOGS", hint_text_in_marker=BASE64_HINT_TEXT_IN_MARKER), re.IGNORECASE
)
DOGS_FILE_END_MARKER_REGEX = re.compile(r"^\sğŸ•\s-{3,}\sDOGS_END_FILE\s-{3,}$", re.IGNORECASE)

PAWS_CMD_REGEX = re.compile(r"^\s*@@\sPAWS_CMD\s(.+?)\s*@@\s*$")
REPLACE_LINES_REGEX = re.compile(r"REPLACE_LINES(\s*(\d+)\s*,\s*(\d+)\s*)", re.IGNORECASE)
INSERT_AFTER_LINE_REGEX = re.compile(r"INSERT_AFTER_LINE(\s*(\d+)\s*)", re.IGNORECASE)
DELETE_LINES_REGEX = re.compile(r"DELETE_LINES(\s*(\d+)\s*,\s*(\d+)\s*)", re.IGNORECASE)

LLM_EDITING_FILE_REGEX = re.compile(
r"^\s*(?:**|)?(?:editing|generating|file|now generating file|processing|current file)\s*(?::)?\s*[\"]?(?P<filepath>[\w./\\~-]+)["]?(?:\s*(.)|\s\b(?:and|also|with|which)\b.|\s+`?#.|\s*(?:**|).*)?
")

ParsedFile = Dict[str, Any]
DeltaCommand = Dict[str, Any]
ExtractionResult = Dict[str, str]
ParseResult = Tuple[List[ParsedFile], str, str]

def sanitize_path_component(comp: str) -> str:
if not comp or comp == "." or comp == "..": return "sanitized_dots"
sanitized = re.sub(r"[^\w.\-_]", "", comp)
sanitized = re.sub(r"+", "", sanitized)
sanitized = re.sub(r"^[.]+|[._]+$", "", sanitized)
return sanitized if sanitized else "sanitized_empty_comp"

def sanitize_relative_path(rel_path_from_bundle: str) -> str:
normalized_path = rel_path_from_bundle.replace("\", "/")
parts = [p for p in normalized_path.split("/") if p and p != "." and p != ".."]
sanitized_parts = [sanitize_path_component(part) for part in parts]
if not sanitized_parts:
sanitized_base = sanitize_path_component(os.path.basename(rel_path_from_bundle))
return sanitized_base if sanitized_base else "unnamed_file_from_bundle"
return os.path.join(*sanitized_parts)

def parse_original_bundle_for_delta(original_bundle_path: str, verbose_logging: bool = False) -> Dict[str, List[str]]:
original_files: Dict[str, List[str]] = {}
try:
with open(original_bundle_path, "rb") as f_orig_bytes:
bundle_bytes = f_orig_bytes.read()
except Exception as e:
print(f" Error: Could not read original bundle '{original_bundle_path}' for delta: {e}", file=sys.stderr)
return {}

header_text_sample = bundle_bytes[:1024].decode(DEFAULT_ENCODING, errors='ignore')
original_bundle_encoding = DEFAULT_ENCODING
if BUNDLE_FORMAT_PREFIX.lower() + "raw utf-16le" in header_text_sample.lower():
    original_bundle_encoding = 'utf-16le'

try:
    original_content_str = bundle_bytes.decode(original_bundle_encoding, errors='replace')
except Exception as e:
    print(f"  Error: Could not decode original bundle '{original_bundle_path}' as {original_bundle_encoding}: {e}", file=sys.stderr)
    return {}

lines = original_content_str.splitlines()
current_file_path: Optional[str] = None
current_content_lines: List[str] = []
in_block = False

for line_text in lines:
    stripped_line = line_text.strip()
    start_match = CATS_FILE_START_MARKER_REGEX.match(stripped_line) # Original bundle uses CATS markers
    end_match = CATS_FILE_END_MARKER_REGEX.match(stripped_line)

    if start_match:
        if in_block and current_file_path:
            if verbose_logging: print(f"  Warning (Original Parse): New file '{start_match.group(1).strip()}' started before '{current_file_path}' ended.", file=sys.stderr)
            original_files[current_file_path] = current_content_lines
        current_file_path = start_match.group(1).strip()
        current_content_lines = []
        in_block = True
        continue

    if end_match and in_block:
        if current_file_path: original_files[current_file_path] = current_content_lines
        current_file_path = None; current_content_lines = []; in_block = False
        continue
    if in_block: current_content_lines.append(line_text)

if in_block and current_file_path:
    if verbose_logging: print(f"  Warning (Original Parse): Bundle ended mid-file for '{current_file_path}'.", file=sys.stderr)
    original_files[current_file_path] = current_content_lines
return original_files
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

def parse_bundle_content(
bundle_content_str: str,
forced_format_override: Optional[str] = None,
apply_delta: bool = False,
verbose_logging: bool = False,
) -> ParseResult:
lines = bundle_content_str.splitlines()
parsed_files: List[ParsedFile] = []

bundle_is_globally_b64: bool = False
bundle_text_content_encoding: str = DEFAULT_ENCODING
format_description = "Unknown (Header not found or not recognized)"
header_lines_consumed = 0
header_type_found: Optional[str] = None

possible_headers = [
    (DOGS_BUNDLE_HEADER_PREFIX, "Dogs Bundle (LLM Output)"),
    (CATS_BUNDLE_HEADER_PREFIX, "Cats Bundle (Original Source)"),
]

for i, line_text in enumerate(lines[:10]):
    stripped = line_text.strip()
    if not header_type_found:
        for prefix_str, desc_str_part in possible_headers:
            if stripped.startswith(prefix_str):
                header_type_found = desc_str_part; header_lines_consumed = max(header_lines_consumed, i + 1); break
        if header_type_found: continue
    
    if header_type_found and stripped.startswith(BUNDLE_FORMAT_PREFIX):
        header_lines_consumed = max(header_lines_consumed, i + 1)
        temp_format_description = stripped[len(BUNDLE_FORMAT_PREFIX) :].strip()
        format_description = f"{header_type_found} - Format: {temp_format_description}"
        fmt_lower = temp_format_description.lower()

        if "base64" in fmt_lower:
            bundle_is_globally_b64 = True; bundle_text_content_encoding = "ascii"
        elif "utf-16le" in fmt_lower or "utf-16 le" in fmt_lower:
            bundle_is_globally_b64 = False; bundle_text_content_encoding = "utf-16le"
        elif "utf-8" in fmt_lower:
            bundle_is_globally_b64 = False; bundle_text_content_encoding = "utf-8"
        else:
            bundle_is_globally_b64 = False; bundle_text_content_encoding = "utf-8"
            format_description += f" (Unrecognized details, assuming Raw UTF-8 for text blocks)"
        break

if forced_format_override:
    override_lower = forced_format_override.lower()
    desc_prefix = f"{header_type_found or 'Bundle'} - Format:"
    if override_lower == "b64":
        bundle_is_globally_b64 = True; bundle_text_content_encoding = "ascii"
        format_description = f"{desc_prefix} Base64 (Overridden by user)"
    elif override_lower == "utf16le":
        bundle_is_globally_b64 = False; bundle_text_content_encoding = "utf-16le"
        format_description = f"{desc_prefix} Raw UTF-16LE (Overridden by user)"
    elif override_lower == "utf8":
        bundle_is_globally_b64 = False; bundle_text_content_encoding = "utf-8"
        format_description = f"{desc_prefix} Raw UTF-8 (Overridden by user)"

if not header_type_found and not forced_format_override:
    format_description = f"Raw UTF-8 (Assumed, no valid header found)"
    if verbose_logging: print(f"  Info: {format_description}", file=sys.stderr)

current_state = "LOOKING_FOR_ANY_START"
current_file_path: Optional[str] = None
current_content_lines: List[str] = []
current_delta_commands: List[DeltaCommand] = []
is_current_file_base64_marked_by_hint = False
has_delta_commands_in_block = False
in_markdown_code_block_heuristic = False
line_iter_obj = iter(enumerate(lines[header_lines_consumed:]))

def finalize_current_block():
    nonlocal parsed_files, current_file_path, current_content_lines, current_delta_commands
    nonlocal has_delta_commands_in_block, is_current_file_base64_marked_by_hint
    if not current_file_path: return

    file_content_bytes: Optional[bytes] = None
    delta_cmds_to_store: Optional[List[DeltaCommand]] = None
    decode_format_used = "text"

    # Determine if content is Base64 due to per-file hint OR global bundle format
    is_content_effectively_base64 = bundle_is_globally_b64 or is_current_file_base64_marked_by_hint

    if apply_delta and has_delta_commands_in_block and not is_content_effectively_base64:
        if current_delta_commands and current_delta_commands[-1]["type"] != "delete" and current_content_lines:
            current_delta_commands[-1]["content_lines"] = list(current_content_lines)
        delta_cmds_to_store = list(current_delta_commands)
        decode_format_used = "delta"
    else:
        raw_content_str = "\n".join(current_content_lines)
        try:
            if is_content_effectively_base64:
                file_content_bytes = base64.b64decode("".join(raw_content_str.split()))
                decode_format_used = "base64"
            else:
                file_content_bytes = raw_content_str.encode(bundle_text_content_encoding)
                decode_format_used = bundle_text_content_encoding
        except Exception as e:
            print(f"  Error: Failed to decode content for '{current_file_path}'. Skipped. Error: {e}", file=sys.stderr)
            current_file_path = None; current_content_lines = []; current_delta_commands = []
            has_delta_commands_in_block = False; is_current_file_base64_marked_by_hint = False
            return

    parsed_files.append({
        "path_in_bundle": current_file_path,
        "content_bytes": file_content_bytes,
        "delta_commands": delta_cmds_to_store,
        "format_used_for_decode": decode_format_used,
        "is_base64_marked_by_hint": is_current_file_base64_marked_by_hint,
        "is_globally_base64": bundle_is_globally_b64,
        "has_delta_commands": has_delta_commands_in_block and not is_content_effectively_base64,
    })
    current_file_path = None; current_content_lines = []; current_delta_commands = []
    has_delta_commands_in_block = False; is_current_file_base64_marked_by_hint = False

for _, line_text in line_iter_obj:
    stripped_line = line_text.strip()
    
    if current_state == "IN_EXPLICIT_BLOCK":
        is_dogs_end = DOGS_FILE_END_MARKER_REGEX.match(stripped_line)
        is_cats_end = CATS_FILE_END_MARKER_REGEX.match(stripped_line)
        if is_dogs_end or is_cats_end:
            finalize_current_block()
            current_state = "LOOKING_FOR_ANY_START"
            continue
    
    is_content_effectively_base64_for_current_block = bundle_is_globally_b64 or is_current_file_base64_marked_by_hint
    if current_state == "IN_EXPLICIT_BLOCK" and apply_delta and not is_content_effectively_base64_for_current_block:
        paws_cmd_match = PAWS_CMD_REGEX.match(line_text)
        if paws_cmd_match:
            command_str = paws_cmd_match.group(1).strip(); delta_cmd: Optional[DeltaCommand] = None
            replace_m = REPLACE_LINES_REGEX.match(command_str); insert_m = INSERT_AFTER_LINE_REGEX.match(command_str); delete_m = DELETE_LINES_REGEX.match(command_str)
            
            if current_delta_commands and current_delta_commands[-1]["type"] != "delete":
                current_delta_commands[-1]["content_lines"] = list(current_content_lines)
            current_content_lines = []

            if replace_m: delta_cmd = {"type": "replace", "start": int(replace_m.group(1)), "end": int(replace_m.group(2))}
            elif insert_m: delta_cmd = {"type": "insert", "line_num": int(insert_m.group(1))}
            elif delete_m: delta_cmd = {"type": "delete", "start": int(delete_m.group(1)), "end": int(delete_m.group(2))}
            
            if delta_cmd:
                current_delta_commands.append(delta_cmd); has_delta_commands_in_block = True
            else:
                if verbose_logging: print(f"  Warning: Unrecognized PAWS_CMD: '{command_str}'", file=sys.stderr)
                current_content_lines.append(line_text)
            continue

    if current_state == "LOOKING_FOR_ANY_START":
        dogs_start_match = DOGS_FILE_START_MARKER_REGEX.match(stripped_line)
        cats_start_match = CATS_FILE_START_MARKER_REGEX.match(stripped_line)
        chosen_match = dogs_start_match or cats_start_match # Prioritize DOGS if both (unlikely)

        if chosen_match:
            finalize_current_block()
            current_file_path = chosen_match.group(1).strip()
            base64_hint_from_match = None
            try: base64_hint_from_match = chosen_match.group(3) # Group 3 is specific hint text
            except IndexError: pass
            is_current_file_base64_marked_by_hint = bool(base64_hint_from_match and BASE64_HINT_TEXT_IN_MARKER in base64_hint_from_match)
            
            current_state = "IN_EXPLICIT_BLOCK"
            current_content_lines = []; current_delta_commands = []; has_delta_commands_in_block = False
            in_markdown_code_block_heuristic = False
            continue
        elif LLM_EDITING_FILE_REGEX.match(line_text) and not apply_delta and not bundle_is_globally_b64:
            finalize_current_block()
            llm_match = LLM_EDITING_FILE_REGEX.match(line_text)
            current_file_path = llm_match.group("filepath").strip()
            is_current_file_base64_marked_by_hint = False
            current_state = "IN_HEURISTIC_BLOCK"
            current_content_lines = []; current_delta_commands = []; has_delta_commands_in_block = False
            try:
                _, next_line_text_heuristic = next(line_iter_obj)
                if MARKDOWN_CODE_FENCE_REGEX.match(next_line_text_heuristic.strip()): in_markdown_code_block_heuristic = True
                else: current_content_lines.append(next_line_text_heuristic)
            except StopIteration: pass
            continue
    
    if current_state == "IN_EXPLICIT_BLOCK" or current_state == "IN_HEURISTIC_BLOCK":
        if current_state == "IN_HEURISTIC_BLOCK" and MARKDOWN_CODE_FENCE_REGEX.match(stripped_line):
            if in_markdown_code_block_heuristic:
                finalize_current_block(); current_state = "LOOKING_FOR_ANY_START"; in_markdown_code_block_heuristic = False
            else: in_markdown_code_block_heuristic = True
            continue
        current_content_lines.append(line_text)

finalize_current_block()
return parsed_files, format_description, bundle_text_content_encoding
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

def apply_delta_commands(original_lines: List[str], delta_commands: List[DeltaCommand], file_path_for_log: str) -> List[str]:
new_lines = list(original_lines); offset = 0
for cmd_idx, cmd in enumerate(delta_commands):
cmd_type = cmd["type"]
try:
if cmd_type == "replace":
s, e = cmd["start"], cmd["end"]
if not (isinstance(s,int) and isinstance(e,int) and s > 0 and e >= s): raise ValueError("Invalid line numbers for replace")
adj_s, adj_e = s - 1 + offset, e - 1 + offset
if not (0 <= adj_s <= adj_e < len(new_lines) or (adj_s == 0 and adj_e == -1 and not new_lines)): # handles empty file replacement
# Allow replacing entire empty file (s=1, e=0 becomes adj_s=0, adj_e=-1)
if not (s == 1 and e == 0 and not new_lines and adj_s == 0 and adj_e == -1):
raise ValueError(f"Replace line numbers {s}-{e} (adj {adj_s}-{adj_e}) out of bounds for file length {len(new_lines)}")

del_count = (adj_e - adj_s + 1) if adj_e >= adj_s else 0 # Handles empty replacement
            content = cmd.get("content_lines", [])
            new_lines[adj_s : adj_e + 1] = content
            offset += len(content) - del_count
        elif cmd_type == "insert":
            ln = cmd["line_num"]
            if not (isinstance(ln, int) and ln >= 0): raise ValueError("Invalid line number for insert")
            adj_ln = ln + offset
            if not (0 <= adj_ln <= len(new_lines)): raise ValueError(f"Insert line number {ln} (adj {adj_ln}) out of bounds for file length {len(new_lines)}")
            
            content = cmd.get("content_lines", [])
            new_lines[adj_ln:adj_ln] = content
            offset += len(content)
        elif cmd_type == "delete":
            s, e = cmd["start"], cmd["end"]
            if not (isinstance(s,int) and isinstance(e,int) and s > 0 and e >= s): raise ValueError("Invalid line numbers for delete")
            adj_s, adj_e = s - 1 + offset, e - 1 + offset
            if not (0 <= adj_s <= adj_e < len(new_lines)): raise ValueError(f"Delete line numbers {s}-{e} (adj {adj_s}-{adj_e}) out of bounds for file length {len(new_lines)}")

            del_count = adj_e - adj_s + 1
            del new_lines[adj_s : adj_e + 1]
            offset -= del_count
    except Exception as e_delta:
        print(f"  Error applying delta #{cmd_idx+1} ({cmd_type}) to '{file_path_for_log}': {e_delta}. Original state likely preserved for this file.", file=sys.stderr)
        return original_lines # Return original on error to prevent partial application
return new_lines
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

def extract_bundle_to_disk(
parsed_files: List[ParsedFile],
output_dir_base_abs: str,
overwrite_policy: str,
bundle_text_content_encoding_for_delta_output: str,
apply_delta_from_original_bundle_path: Optional[str] = None,
verbose_logging: bool = False,
) -> List[ExtractionResult]:
results: List[ExtractionResult] = []
always_yes, always_no, user_quit = overwrite_policy == "yes", overwrite_policy == "no", False

original_bundle_files_for_delta: Dict[str, List[str]] = {}
if apply_delta_from_original_bundle_path:
    original_bundle_files_for_delta = parse_original_bundle_for_delta(apply_delta_from_original_bundle_path, verbose_logging)
    if not original_bundle_files_for_delta and any(f.get("has_delta_commands") for f in parsed_files):
        print(f"  Warning: Delta active, but failed to load/parse original bundle '{apply_delta_from_original_bundle_path}'. Deltas for text files cannot be applied.", file=sys.stderr)
        apply_delta_from_original_bundle_path = None

for file_info in parsed_files:
    if user_quit: results.append({"path": file_info["path_in_bundle"], "status": "skipped", "message": "User quit."}); continue

    original_path = file_info["path_in_bundle"]
    sanitized_rel_path = sanitize_relative_path(original_path)
    prospective_abs_path = os.path.normpath(os.path.join(output_dir_base_abs, sanitized_rel_path))

    if not os.path.abspath(prospective_abs_path).startswith(os.path.abspath(output_dir_base_abs)):
        msg = f"Security Alert: Path '{sanitized_rel_path}' (from '{original_path}') escapes base dir. Skipping."
        print(f"  Error: {msg}", file=sys.stderr); results.append({"path": original_path, "status": "error", "message": msg}); continue

    content_to_write: Optional[bytes] = None
    should_write_file = True

    if apply_delta_from_original_bundle_path and file_info.get("has_delta_commands"): # No is_base64_marked check here; deltas are only for text
        original_lines = original_bundle_files_for_delta.get(original_path)
        delta_cmds = file_info.get("delta_commands")
        if original_lines is None:
            msg = f"Delta for '{original_path}', but not in original bundle. Writing full content if available."; print(f"  Warning: {msg}", file=sys.stderr)
            content_to_write = file_info.get("content_bytes") # Fallback to full if original not found for delta
            if content_to_write is None:
                results.append({"path": original_path, "status": "error", "message": "No full content for delta fallback."}); should_write_file = False
        elif not delta_cmds:
            msg = f"Internal: Delta flagged but no commands for '{original_path}'. Writing full content."; print(f"  Warning: {msg}", file=sys.stderr)
            content_to_write = file_info.get("content_bytes")
            if content_to_write is None:
                results.append({"path": original_path, "status": "error", "message": "No full content for delta fallback."}); should_write_file = False
        else:
            new_content_lines = apply_delta_commands(original_lines, delta_cmds, original_path)
            try:
                content_to_write = "\n".join(new_content_lines).encode(bundle_text_content_encoding_for_delta_output)
                if verbose_logging: print(f"  Info: Delta result for '{original_path}' encoded as {bundle_text_content_encoding_for_delta_output}.")
            except Exception as enc_e:
                msg = f"Failed to encode delta result for '{original_path}': {enc_e}"; print(f"  Error: {msg}", file=sys.stderr)
                results.append({"path": original_path, "status": "error", "message": msg}); should_write_file = False
    else:
        content_to_write = file_info.get("content_bytes")
        if content_to_write is None:
            msg = "No content to write (parsing issue or unexpected empty delta block)."
            if not any(r["path"] == original_path and r["status"] == "error" for r in results):
                results.append({"path": original_path, "status": "error", "message": msg})
            should_write_file = False
    
    if should_write_file and content_to_write is not None:
        if os.path.lexists(prospective_abs_path):
            if os.path.isdir(prospective_abs_path) and not os.path.islink(prospective_abs_path):
                msg = f"Path '{sanitized_rel_path}' is a directory. Skipping."; print(f"  Warning: {msg}", file=sys.stderr)
                results.append({"path": original_path, "status": "error", "message": msg}); should_write_file = False
            elif always_no: results.append({"path": original_path, "status": "skipped", "message": "Exists (no overwrite)."}) ; should_write_file = False
            elif not always_yes:
                if not sys.stdin.isatty(): results.append({"path": original_path, "status": "skipped", "message": "Exists (non-interactive, no overwrite)."}) ; should_write_file = False
                else:
                    try:
                        choice = input(f"File '{sanitized_rel_path}' exists. Overwrite? [y/N/a/s/q]: ").strip().lower()
                        if choice == 'y': pass
                        elif choice == 'a': always_yes = True
                        elif choice == 's': always_no = True; should_write_file = False; results.append({"path": original_path, "status": "skipped", "message": "Exists (skip all)."})
                        elif choice == 'q': user_quit = True; should_write_file = False
                        else: should_write_file = False; results.append({"path": original_path, "status": "skipped", "message": "Exists (user no)."})
                    except (KeyboardInterrupt, EOFError): user_quit = True; should_write_file = False; print("\nExtraction cancelled.")
        
        if user_quit and not should_write_file:
            if not any(r["path"] == original_path and r["status"] == "skipped" for r in results): results.append({"path": original_path, "status": "skipped", "message": "User quit."})
            continue

        if should_write_file:
            try:
                os.makedirs(os.path.dirname(prospective_abs_path), exist_ok=True)
                if os.path.islink(prospective_abs_path): os.unlink(prospective_abs_path)
                with open(prospective_abs_path, "wb") as f_out: f_out.write(content_to_write)
                results.append({"path": original_path, "status": "extracted", "message": f"To {sanitized_rel_path}"})
            except Exception as e_write:
                msg = f"Error writing '{sanitized_rel_path}': {e_write}"; print(f"  Error: {msg}", file=sys.stderr)
                results.append({"path": original_path, "status": "error", "message": msg})
return results
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

def extract_bundle_to_memory(
bundle_content_str: Optional[str] = None, bundle_path: Optional[str] = None,
input_format_override: Optional[str] = None, verbose_logging: bool = False,
) -> List[ParsedFile]:
if bundle_path and not bundle_content_str:
try:
with open(bundle_path, "r", encoding=DEFAULT_ENCODING, errors="replace") as f: bundle_content_str = f.read()
except Exception as e: print(f"Error reading bundle file '{bundle_path}': {e}", file=sys.stderr); return []
if bundle_content_str is None: print("Error: No bundle content or path provided for memory extraction.", file=sys.stderr); return []

parsed_files, _, _ = parse_bundle_content(
    bundle_content_str, 
    forced_format_override=input_format_override, 
    apply_delta=True, # Parse for deltas, but they won't be applied by this function.
    verbose_logging=verbose_logging
)
return parsed_files
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

def extract_bundle_from_string(
bundle_content_str: Optional[str] = None, bundle_path: Optional[str] = None,
output_dir_base: str = ".", overwrite_policy: str = "prompt",
apply_delta_from_original_bundle_path: Optional[str] = None,
input_format_override: Optional[str] = None, verbose_logging: bool = False,
) -> List[ExtractionResult]:
if bundle_path and not bundle_content_str:
try:
with open(bundle_path, "r", encoding=DEFAULT_ENCODING, errors="replace") as f: bundle_content_str = f.read()
except Exception as e: return [{"path": bundle_path, "status": "error", "message": f"Read error: {e}"}]
if bundle_content_str is None: return [{"path": "bundle", "status": "error", "message": "No bundle content provided."}]

abs_output_dir = os.path.realpath(os.path.abspath(output_dir_base))
try: os.makedirs(abs_output_dir, exist_ok=True)
except Exception as e: return [{"path": output_dir_base, "status": "error", "message": f"Mkdir error: {e}"}]
if not os.path.isdir(abs_output_dir): return [{"path": output_dir_base, "status": "error", "message": "Output path is not a directory."}]

parsed_files, format_desc, bundle_text_enc_for_delta = parse_bundle_content(
    bundle_content_str, input_format_override,
    apply_delta=bool(apply_delta_from_original_bundle_path), verbose_logging=verbose_logging
)
if verbose_logging: print(f"  Info: Bundle parsing done. Format: {format_desc}. Files found: {len(parsed_files)}.")
if not parsed_files: return [{"path": "bundle", "status": "skipped", "message": "No files were parsed from the bundle."}]

return extract_bundle_to_disk(
    parsed_files, abs_output_dir, overwrite_policy,
    bundle_text_enc_for_delta,
    apply_delta_from_original_bundle_path, verbose_logging
)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

def confirm_action_cli_prompt(prompt_message: str) -> bool:
if not sys.stdin.isatty(): return True
while True:
try:
choice = input(f"{prompt_message} [Y/n]: ").strip().lower()
if choice == "y" or choice == "": return True
if choice == "n": return False
print("Invalid input.", file=sys.stderr)
except (KeyboardInterrupt, EOFError): print("\nOperation cancelled.", file=sys.stderr); return False

def main_cli():
parser = argparse.ArgumentParser(
description="dogs.py : Extracts files from a PAWS bundle, handling mixed content and deltas.",
epilog="Example: python dogs.py results.bundle ./code -y -d project_orig.bundle",
formatter_class=argparse.RawTextHelpFormatter
)
parser.add_argument("bundle_file", nargs="?", default=None, metavar="BUNDLE_FILE", help=f"Bundle to extract (default: {DEFAULT_INPUT_BUNDLE_FILENAME} if exists).")
parser.add_argument("output_directory", nargs="?", default=DEFAULT_OUTPUT_DIR, metavar="OUTPUT_DIR", help=f"Directory to extract into (default: {DEFAULT_OUTPUT_DIR}).")
parser.add_argument("-d", "--apply-delta", metavar="ORIGINAL_BUNDLE", help="Apply delta commands (for text files) using ORIGINAL_BUNDLE as base.")
parser.add_argument("-i", "--input-format", choices=["auto", "b64", "utf8", "utf16le"], default="auto", help="Override bundle's primary text format detection (default: auto). Per-file Base64 markers are still honored.")
overwrite_group = parser.add_mutually_exclusive_group()
overwrite_group.add_argument("-y", "--yes", dest="overwrite_policy", action="store_const", const="yes", help="Automatically overwrite existing files.")
overwrite_group.add_argument("-n", "--no", dest="overwrite_policy", action="store_const", const="no", help="Automatically skip existing files.")
parser.set_defaults(overwrite_policy="prompt")
parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose logging.")

args = parser.parse_args()
if args.bundle_file is None:
    if os.path.exists(DEFAULT_INPUT_BUNDLE_FILENAME): args.bundle_file = DEFAULT_INPUT_BUNDLE_FILENAME
    else: parser.error(f"No bundle file specified and default '{DEFAULT_INPUT_BUNDLE_FILENAME}' not found.")

abs_bundle_file_path = os.path.realpath(os.path.abspath(args.bundle_file))
if not os.path.isfile(abs_bundle_file_path): 
    print(f"Error: Bundle file not found: '{abs_bundle_file_path}'", file=sys.stderr); sys.exit(1)

abs_original_bundle_path = None
if args.apply_delta:
    abs_original_bundle_path = os.path.realpath(os.path.abspath(args.apply_delta))
    if not os.path.isfile(abs_original_bundle_path): 
        print(f"Error: Original bundle for delta not found: '{abs_original_bundle_path}'", file=sys.stderr); sys.exit(1)

bundle_content_str = ""
try:
    with open(abs_bundle_file_path, "r", encoding=DEFAULT_ENCODING, errors="replace") as f: 
        bundle_content_str = f.read()
except Exception as e: 
    print(f"Error reading bundle file '{abs_bundle_file_path}': {e}", file=sys.stderr); sys.exit(1)

effective_overwrite_policy = args.overwrite_policy
if not sys.stdin.isatty() and args.overwrite_policy == "prompt": 
    effective_overwrite_policy = "no"

parsed_for_confirm, prelim_fmt_desc, _ = parse_bundle_content(
    bundle_content_str,
    forced_format_override=(args.input_format if args.input_format != "auto" else None),
    apply_delta=bool(abs_original_bundle_path), 
    verbose_logging=False 
)
num_files_prelim = len(parsed_for_confirm)
num_delta_files_prelim = sum(1 for pf in parsed_for_confirm if pf.get("has_delta_commands"))
num_b64_marked_prelim = sum(1 for pf in parsed_for_confirm if pf.get("is_base64_marked_by_hint"))

if args.overwrite_policy == "prompt" and sys.stdin.isatty() and num_files_prelim > 0 :
    print(f"\n--- Bundle Extraction Plan ---\n"
          f"  Source Bundle:    {abs_bundle_file_path}\n"
          f"  Output Directory: {os.path.realpath(os.path.abspath(args.output_directory))}\n"
          f"  Detected Format:  {prelim_fmt_desc}" + 
          (f"\n  Format Override:  Interpreting primary text as {args.input_format.upper()}" if args.input_format != "auto" else "") +
          (f"\n  Original Bundle:  {abs_original_bundle_path} (for Delta)" if abs_original_bundle_path else "") +
          f"\n  Overwrite Policy: {args.overwrite_policy.capitalize()}\n"
          f"  Files to process: {num_files_prelim}" +
          (f" ({num_delta_files_prelim} with deltas)" if num_delta_files_prelim > 0 else "") +
          (f" ({num_b64_marked_prelim} marked Base64)" if num_b64_marked_prelim > 0 else ""))
    if not confirm_action_cli_prompt("\nProceed with extraction?"): 
        print("Extraction cancelled by user.", file=sys.stderr); return

print("\nStarting extraction process...", file=sys.stderr)
extraction_results = extract_bundle_from_string(
    bundle_content_str=bundle_content_str, output_dir_base=args.output_directory,
    overwrite_policy=effective_overwrite_policy,
    apply_delta_from_original_bundle_path=abs_original_bundle_path,
    input_format_override=(args.input_format if args.input_format != "auto" else None),
    verbose_logging=args.verbose
)

ext = sum(1 for r in extraction_results if r["status"] == "extracted")
skip = sum(1 for r in extraction_results if r["status"] == "skipped")
err = sum(1 for r in extraction_results if r["status"] == "error")
print(f"\n--- Extraction Summary ---\n  Files Extracted: {ext}" + 
      (f"\n  Files Skipped:   {skip}" if skip > 0 else "") + 
      (f"\n  Errors:          {err}" if err > 0 else ""), file=sys.stderr)
if num_files_prelim == 0 and not any(r["status"]=="error" for r in extraction_results) : 
    print("  No file content was found or parsed in the bundle.", file=sys.stderr)
if err > 0: sys.exit(1)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

if name == "main":
try:
main_cli()
except SystemExit:
raise
except KeyboardInterrupt:
print("\nOperation cancelled by user (KeyboardInterrupt).", file=sys.stderr)
sys.exit(130)
except Exception as e:
print(f"\nAn unexpected critical error occurred in dogs.py main: {e}", file=sys.stderr)
import traceback
traceback.print_exc(file=sys.stderr)
sys.exit(1)
ğŸ• --- DOGS_END_FILE ---
