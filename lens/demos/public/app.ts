/**
 * MCP Lens Demo Dashboard
 * Client-side application (TypeScript)
 *
 * Note: This TypeScript file can be used directly with a bundler (webpack/vite)
 * or the compiled .js version can be used directly in browsers.
 */

// Extend Window interface for global functions
declare global {
  interface Window {
    selectServer: (serverName: string) => Promise<void>;
    executeTool: (serverName: string, toolName: string) => void;
    confirmToolExecution: () => Promise<void>;
    cancelToolExecution: () => void;
    executeExample: (index: number) => Promise<void>;
  }
}

const API_BASE = 'http://localhost:3000/api';

interface Server {
  name: string;
  description: string;
  state: string;
}

interface Tool {
  name: string;
  description?: string;
  inputSchema?: any;
}

interface Example {
  name: string;
  server: string;
  tool: string;
  args: any;
}

interface PendingToolExecution {
  server: string;
  tool: string;
  args: any;
}

let servers: Server[] = [];
let pendingToolExecution: PendingToolExecution | null = null;

// Initialize dashboard
async function init(): Promise<void> {
  await loadServers();
  await loadExamples();
  setupEventListeners();
  connectWebSocket();

  addLog('info', 'Dashboard ready');
}

// Load MCP servers
async function loadServers(): Promise<void> {
  try {
    const response = await fetch(`${API_BASE}/servers`);
    const data = await response.json();

    servers = data.servers;

    renderServers();
    populateServerSelect();

    addLog('success', `Loaded ${servers.length} MCP servers`);
  } catch (error) {
    addLog('error', `Failed to load servers: ${error.message}`);
  }
}

// Render servers list
function renderServers() {
  const list = document.getElementById('server-list');

  list.innerHTML = servers.map(server => `
    <li class="server-item" onclick="selectServer('${server.name}')">
      <span class="server-status ${server.state}"></span>
      <span class="server-name">${server.name}</span>
      <div class="server-description">${server.description}</div>
    </li>
  `).join('');
}

// Populate server dropdown
function populateServerSelect() {
  const select = document.getElementById('server-select');

  select.innerHTML = '<option value="">Select a server...</option>' +
    servers.map(server => `
      <option value="${server.name}">${server.name}</option>
    `).join('');
}

// Select a server and load its tools
async function selectServer(serverName: string): Promise<void> {
  const select = document.getElementById('server-select') as HTMLSelectElement;
  select.value = serverName;

  await loadTools(serverName);
}

// Load tools from selected server
async function loadTools(serverName: string): Promise<void> {
  if (!serverName) {
    const grid = document.getElementById('tools-grid') as HTMLElement;
    grid.innerHTML = `
      <div style="grid-column: 1 / -1; text-align: center; color: #95a5a6; padding: 24px;">
        Select a server to view tools
      </div>
    `;
    return;
  }

  try {
    const response = await fetch(`${API_BASE}/servers/${serverName}/tools`);
    const data = await response.json();

    renderTools(serverName, data.tools);
    addLog('info', `Loaded ${data.tools.length} tools from ${serverName}`);
  } catch (error) {
    addLog('error', `Failed to load tools: ${error.message}`);
  }
}

// Render tools grid
function renderTools(serverName, tools) {
  const grid = document.getElementById('tools-grid');

  if (tools.length === 0) {
    grid.innerHTML = `
      <div style="grid-column: 1 / -1; text-align: center; color: #95a5a6; padding: 24px;">
        No tools available
      </div>
    `;
    return;
  }

  grid.innerHTML = tools.map(tool => `
    <div class="tool-card" onclick='executeTool("${serverName}", "${tool.name}")'>
      <div class="tool-name">${tool.name}</div>
      <div class="tool-description">${tool.description || 'No description'}</div>
    </div>
  `).join('');
}

// Get sensible default arguments for a tool
function getDefaultArgs(serverName, toolName) {
  // Filesystem defaults
  if (serverName === 'filesystem') {
    switch (toolName) {
      case 'read_file':
      case 'read_text_file':
        return { path: './sandbox/example.txt' };
      case 'list_directory':
        return { path: './sandbox' };
      case 'directory_tree':
        return { path: './sandbox' };
      case 'get_file_info':
        return { path: './sandbox/example.txt' };
      case 'write_file':
        return { path: './sandbox/output.txt', content: 'Generated by MCP Lens demo at ' + new Date().toISOString() };
      case 'search_files':
        return { path: './sandbox', pattern: '*.txt' };
      case 'read_multiple_files':
        return { paths: ['./sandbox/example.txt', './sandbox/notes.txt'] };
      default:
        return {};
    }
  }

  // Memory (Knowledge Graph) defaults
  if (serverName === 'memory') {
    switch (toolName) {
      case 'create_entities':
        return {
          entities: [{
            name: 'MCP Lens Dashboard',
            entityType: 'Application',
            observations: ['Interactive web interface', 'Real-time monitoring', 'Tool execution']
          }]
        };
      case 'read_graph':
        return {};
      case 'search_nodes':
        return { query: 'Lens' };
      default:
        return {};
    }
  }

  // Sequential thinking defaults
  if (serverName === 'sequential-thinking') {
    switch (toolName) {
      case 'sequentialthinking':
        return {
          thought: 'Analyzing the MCP Lens demo dashboard functionality',
          nextThoughtNeeded: false,
          thoughtNumber: 1,
          totalThoughts: 1
        };
      default:
        return {};
    }
  }

  return {};
}

// Execute a tool (with confirmation)
async function executeTool(serverName, toolName) {
  const tool = await getToolInfo(serverName, toolName);
  const args = getDefaultArgs(serverName, toolName);

  // Show confirmation modal
  pendingToolExecution = { serverName, toolName, args };

  const modal = document.getElementById('confirmation-modal');
  const modalBody = document.getElementById('modal-body');

  const argsDisplay = Object.keys(args).length > 0
    ? `<pre style="background: #f5f5f5; padding: 8px; border-radius: 4px; font-size: 12px; max-height: 200px; overflow: auto;">${JSON.stringify(args, null, 2)}</pre>`
    : '<p style="color: #999;">No arguments</p>';

  modalBody.innerHTML = `
    <p><strong>Server:</strong> ${serverName}</p>
    <p><strong>Tool:</strong> ${toolName}</p>
    <p><strong>Description:</strong> ${tool?.description || 'No description'}</p>
    <div style="margin-top: 16px;">
      <strong>Arguments:</strong>
      ${argsDisplay}
    </div>
    <p style="margin-top: 16px;">Do you want to execute this tool?</p>
  `;

  modal.classList.add('active');
}

// Get tool information
async function getToolInfo(serverName, toolName) {
  try {
    const response = await fetch(`${API_BASE}/servers/${serverName}/tools`);
    const data = await response.json();
    return data.tools.find(t => t.name === toolName);
  } catch (error) {
    return null;
  }
}

// Confirm tool execution
async function confirmToolExecution() {
  const modal = document.getElementById('confirmation-modal');
  modal.classList.remove('active');

  if (!pendingToolExecution) return;

  const { serverName, toolName, args } = pendingToolExecution;
  pendingToolExecution = null;

  addLog('info', `Executing ${toolName} on ${serverName}...`);

  try {
    const response = await fetch(`${API_BASE}/servers/${serverName}/tools/${toolName}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ arguments: args })
    });

    const data = await response.json();

    if (response.ok) {
      addLog('success', `${toolName} completed successfully`);

      // Show result preview in activity log
      if (data.result?.content) {
        const preview = data.result.content
          .map(c => c.text || c.data || JSON.stringify(c))
          .join(' ')
          .substring(0, 150);

        if (preview) {
          addLog('info', `â†’ ${preview}${preview.length >= 150 ? '...' : ''}`);
        }
      }

      console.log('Full result:', data.result);
    } else {
      addLog('error', `${toolName} failed: ${data.error}`);
    }
  } catch (error) {
    addLog('error', `${toolName} failed: ${error.message}`);
  }
}

// Cancel tool execution
function cancelToolExecution() {
  const modal = document.getElementById('confirmation-modal');
  modal.classList.remove('active');

  if (pendingToolExecution) {
    addLog('info', `Tool execution cancelled by user`);
    pendingToolExecution = null;
  }
}

// Expose functions to global scope for onclick handlers
window.selectServer = selectServer;
window.executeTool = executeTool;
window.confirmToolExecution = confirmToolExecution;
window.cancelToolExecution = cancelToolExecution;
window.executeExample = executeExample;

// Load example pipelines
async function loadExamples(): Promise<void> {
  try {
    const response = await fetch(`${API_BASE}/examples`);
    const data = await response.json();

    renderExamples(data.examples);
  } catch (error) {
    addLog('error', `Failed to load examples: ${error.message}`);
  }
}

// Render examples list
function renderExamples(examples) {
  const list = document.getElementById('example-list');

  if (examples.length === 0) {
    list.innerHTML = '<li style="padding: 24px; text-align: center; color: #95a5a6;">No examples available</li>';
    return;
  }

  list.innerHTML = examples.map(example => `
    <li class="example-item">
      <div class="example-name">${example.name}</div>
      <div class="example-description">${example.description}</div>
      <div class="example-steps">${example.steps.length} steps</div>
      <button style="margin-top: 8px;" onclick='executeExample("${example.name}")'>
        Run Pipeline
      </button>
    </li>
  `).join('');
}

// Execute an example pipeline
async function executeExample(exampleName) {
  addLog('info', `Starting pipeline: ${exampleName}`);

  try {
    const response = await fetch(`${API_BASE}/examples/${encodeURIComponent(exampleName)}/execute`, {
      method: 'POST'
    });

    const data = await response.json();

    if (response.ok && data.success) {
      addLog('success', `Pipeline completed: ${data.results.length} steps executed`);
      data.results.forEach((result, i) => {
        addLog('info', `Step ${i + 1}: ${result.server}.${result.tool}`);
      });
    } else {
      addLog('error', `Pipeline failed: ${data.error}`);
    }
  } catch (error) {
    addLog('error', `Pipeline failed: ${error.message}`);
  }
}

// Add log entry
function addLog(type, message) {
  const log = document.getElementById('activity-log');
  const timestamp = new Date().toLocaleTimeString();

  const entry = document.createElement('div');
  entry.className = `log-entry ${type}`;
  entry.innerHTML = `
    <span class="log-timestamp">[${timestamp}]</span>
    <span>${message}</span>
  `;

  log.insertBefore(entry, log.firstChild);

  // Keep only last 50 entries
  while (log.children.length > 50) {
    log.removeChild(log.lastChild);
  }
}

// Setup event listeners
function setupEventListeners() {
  const serverSelect = document.getElementById('server-select');
  serverSelect.addEventListener('change', (e) => {
    loadTools(e.target.value);
  });
}

// Connect to WebSocket for real-time updates
function connectWebSocket() {
  const ws = new WebSocket('ws://localhost:3000');

  ws.onopen = () => {
    addLog('success', 'WebSocket connected');
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log('WebSocket message:', data);

    if (data.type === 'server_list') {
      addLog('info', `Received server list: ${data.servers.join(', ')}`);
    }
  };

  ws.onerror = (error) => {
    addLog('error', 'WebSocket error');
  };

  ws.onclose = () => {
    addLog('info', 'WebSocket disconnected');

    // Reconnect after 5 seconds
    setTimeout(connectWebSocket, 5000);
  };
}

// Start the application
init();
